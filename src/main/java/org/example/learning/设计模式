##设计模式常用的七大原则有:(设计模式为什么这样设计的依据)
    1) 单一职责原则
         对类来说的，即一个类应该只负责-项职责。如类A负责两个不同职责:职责1,职责2。当职责1需求变更
        而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为Al, A2
    2) 接口隔离原则
         客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上
        一个类对另一个类的依赖:通过接口产生依赖
    3) 依赖倒转(倒置)原则
        依赖倒转原则(Dependence Inversion Principle)是指:
            1)高层模块不应该依赖低层模块， 二者都应该依赖其抽象
            2)抽象不应该依赖细节，细节应该依赖抽象
            3)依赖倒转(倒置)的中心思想是面向接口编程
            4)依赖倒转原则是基于这样的设计理念:相对于细节的多变性，抽象的东西要稳定的多。
                以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。
                在java中，抽象指的是接口或抽象类，细节就是具体的实现类
            5)使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，
                把展现细节的任务交给他们的实现类去完成
        注意事项:
            1)低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好.
            2)变量的声明类型尽量是抽象类或接口,这样我们的变量引用和实际对象间，就存在
                一个缓冲层，利于程序扩展和优化
            3)继承时遵循里氏替换原则
    4) 里氏替换原则
        OO中的继承性的思考和说明:
            1)继承包含这样一层含义: 父类中凡是已经实现好的方法，实际.上是在设定规范和契
                约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实
                现的方法任意修改，就会对整个继承体系造成破坏。
            2)继承在给程序设计带来便利的同时，**也带来了弊端。比如使用继承会给程序带来侵入性**
                程序的可移植性降低，增加对象间的耦合性，如果-一个类被其他的类所继承，
                则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子
                类的功能都有可能产生故障
            3)问题提出:在编程中，如何正确的使用继承? =>里氏替换原则
        基本介绍:
        1)里氏替换原则(Liskov Substitution Principle)在1988年由麻省理工学院姓里的女士提出的
        2) 如果对每个类型为T1的对象o1,都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的
            对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，
            所有引用基类的地方必须能透明地使用其子类的对象。
        3) 在使用继承时，遵循里氏替换原则，*在子类中尽量不要重写父类的方法*
        4) 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下
            可以通过**聚合，组合，依赖**来解决问题
    5) 开闭原则 ocp
        基本介绍:
            1)开闭原则(Open Closed Principle)是编程中最基础、最重要的设计原则
            2)一个软件实体如类，**模块和函数应该对扩展开放(对提供方)，对修改关闭(使用方)**。
                用抽象构建框架，用实现扩展细节。
            3)当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已
                有的代码来实现变化。
            4)编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。
    6) 迪米特法则
        基本介绍:
            1)一个对象应该对其他对象保持最少的了解
            2)类与类关系越密切，耦合度越大
            3)迪米特法则(Demeter Principle)又叫*最少知道原则*，即*一个类对自已依赖的类知道的
                越少越好***。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内
                部。对外除了提供的public方法，不对外泄露任何信息
            4)迪米特法则还有个更简单的定义:只与直接的朋友通信
            5) *直接的朋友*:每个对象都会与其他对象由耦合关系，只要两个对象之间有耦合关系，
                我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合
                等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而
                出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量
                的形式出现在类的内部。
        迪米特法则注意事项和细节:
            1)迪米特法则的核心是降低类之间的耦合
            2)但是注意:由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低
                类间(对象间)耦合关系，并不是要求完全没有 依赖关系
    7) 合成复用原则
        基本介绍:
            原则是尽量使用合成/聚合的方式，而不是使用继承
                依赖:使用、传参(合成类似于这样) fun(A a){};
                聚合:设置属性 private A a; setA(A:a);
                组合:在属性直接new: private A a = newA();

类之间的关系:
    依赖dependency:A使用了B A依赖B     1)类中用到了对方2)如果是类的成员属性
                    3)如果是方法的返回类型4)是方法接收的参数类型5)方法中使用到
    泛化generalization(继承):如果A继承B  A和B存在泛化关系 ->泛化就是继承
    实现implementation:A实现了B接口  A实现B
    关联association:类与类之间的练习 {A类中private B b = newB();[单向一对一关系]
                        B类中有:private A a = newA();[单向一对一关系]}双向一对一关系
    聚合aggregation:关联关系的一种特例  表示的是整体和部分的关系，整体与部分可以分开。
      例如电脑类有鼠标类属性,也可以没有鼠标类属性 鼠标类可以与电脑类分离,具有关联的导航性与多重性。
    组合composition:也是整体与部分的关系，但是整体与部分不可以分开。
        例如电脑必须要有cpu 则电脑与cpu是组合关系,具有关联的导航性与多重性。


设计原则核心思想:
    1)找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代
    码混在一起 。
    2)针对接口编程，而不是针对实现编程。
    3)为了交互对象之间的松耦合设计而努力

设计模式的目的:
设计模式是为了让程序(软件),具有更好的:
    1)代码重用性(即:相同功能的代码，不用多次编写)
    2)可读性(即:编程规范性,便于其他程序员的阅读和理解)
    3)可扩展性(即:当需要增加新的功能时，非常的方便，称为可维护)
    4)可靠性(即:当我们增加新的功能后，对原来的功能没有影响)
    5)使程序呈现高内聚，低耦合的特性
分享金句:
    设计模式包含了面向对象的精髓，"懂了设计模式，你就懂了面向对象分析和设计(OOA/D)的精要"


设计模式分为三种类型，共23种
    1)创建型模式:*单例模式*、抽象工厂模式、原型模式、建造者模式、*工工模式*。
    2)结构型模式:适配器模式、桥接模式、*装饰模式*、组合模式、外观模式、享元模式、*代理模式*。
    3)行为型模式:模版方法模式、命令模式、访问者模式、迭代器模式、*观察者模式*、中介者模式、
    备忘录模式、解释器模式(Interpreter模式) 、状态模式、策略模式、职责链模式(责任链模式)。

=========创建型模式======================================================
##单例模式##有八种方式:
      所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类
    只能存在一一个对象实例，并且该类只提供-一个取得其对象实例的方法(静态方法)。
    1) 饿汉式(静态常量)
    2) 饿汉式(静态代码块)
    3) 懒汉式(线程不安全)
    4) 懒汉式(线程安全，同步方法)
    5) 懒汉式(线程安全不一定，同步代码块)
    推荐使用:
        6) 双重检查
        7) 静态内部类
        8) 枚举
经典单例模式:java.lang.Runtime
    单例模式注意事项和细节说明
        1)单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需
         要频繁创建销毁的对象，使用单例模式可以提高系統性能
        2)当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
        3)*单例模式使用的场景:需要频繁的进行创建和销毁的对象创建对象时耗时过多或
         耗费资源过多(即:重量级对象)，但又经常用到的对象(工具类对象、频繁访问数
         据库或文件的对象(比如数据源、session工厂等)


##工厂模式##
传统的方式的优缺点:
    1)优点是比较好理解，简单易操作。
    2)缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增
    加新功能的时候，尽量不修改代码，或者尽可能少修改代码.
简单工厂模式:
    1)简单工厂模式是属于创建型模式，是工厂模式的--种。简单工厂模式是由一个工厂对象
      决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式
    2)简单工厂模式:定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)
    3)在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.
工厂方法模式
    设计方案:将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。
    模式:定义了一个创建对象的抽象方法,由子类决定要实例化的类.工厂方法模式将对象的实例化推迟到子类。
抽象工厂模式
    1)抽象工厂模式:定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明且体的类
    2)抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
    3)从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
    4)将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型
      使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。
工厂模式应用在:JDK-Calendar


##原型模式##
基本介绍:
    1)原型模式(Prototype模式)是指:用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
    2)原型模式是一种创建型设计模式,允许一个对象再创建另外一个可定制的对象,无需知道如何创建的细节
    3)工作原理是:通过将一个原型对象传给那个要发动创建的对象,这个要发动创建
      的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()
    4)形象的理解:孙大圣拔出猴毛，变出其它孙大圣
浅拷贝的介绍
    1)对于数据类型是基本数据类型的成员变量,浅拷贝会直接进行值传递,也就是将该属性值复制一份给新的对象
    2)对于数据类型是引用数据类型的成员变量,比如说成员变量是某个数组、某个类的对象等,那么
      浅拷贝会进行引用传递，也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象.因为实际上
      两个对象的该成员变量都指向同一个实例.在这种情况下,在一个对象中修改该成员变量会影响到另一个对象
      的该成员变量值
    3)前面我们克隆羊就是浅拷贝
    4)浅拷贝是使用默认的clone()方法来实现
      sheep = (Sheep) super.clone();
深拷贝基本介绍
    1)复制对象的所有基本数据类型的成员变量值
    2)为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，
      直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括引用对象)进行拷贝
    3)深拷贝实现方式1:重写clone方法来实现深拷贝
    4)深拷贝实现方式2:通过对象序列化实现深拷贝(推荐)
Spring 中原型bean的创建，就是原型模式的应用
原型模式的注意事项和细节:
    1) 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
    2)不用重新初始化对象，而是动态地获得对象运行时的状态
    3)如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码
    4)在实现深克隆的时候可能需要比较复杂的代码
    5)缺点:需要为每一-个类配备一 个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，
      需要修改其源代码，违背了ocp原则，这点请同学们注意.


##建造者模式##
基本介绍
    1) 建造者模式(Builder Pattern) 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的
      建造过程抽象出来<抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。
    2) 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象
      的类型和内容就可以构建它们，用户不需要知道内部的具体构建细书。
建造者模式的四个角色
    TProduct(产品角色):一个具体的产品对象。
    Builder(抽象建造者):创建一个Product对象的各个部件指定的接口/抽象类。
    ConcreteBuilder(具体建造者):实现接口，构建和装配各个部件。
    Director(指挥者):构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。
      它主要有两个作用，一是:隔离了客户与对象的生产过程，二是:负责控制产品对象的生产过程。
注意事项和细节
    1)客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解
      耦，使得相同的创建过程可以创建不同的产品对象
    2)每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替
      换具体建造者或增加新的具体建造者，用 户使用不同的具体建造者即可得到不同的产品对象
    3)可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法
      中，使得创建过程更加清晰，也更方便使用程序来控制创建过程
    4)增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，
      系统扩展方便，符合“开闭原则”
    5)建造者模式所创建的产品一-般具有较多的共同点，其组成部分相似，如果产品之间
      的差异性很大，则不适合使用建造者模式，因此其使用范围受到- -定的限制。
    6)如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，
      导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.
    7)抽象工厂模式VS建造者模式
      抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一-系列产品:具有不
      同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品
      由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要
      目的是通过组装零配件而产生一个新产品


=======结构型模式=====================================

##适配器模式##
基本介绍
    1)适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性,
      让原本因接口不匹配不能一起工作的两个类可以协同工作.其别名为泡装器(Wrapper)
    2)适配器模式属于结构型模式
    3)主要分为三类:**类适配器模式、对象适配器模式、接口适配器模式**
工作原理
    1)适配器模式:将一个类的接口转换成另一种接口.让原本接口不兼容的类可以兼容
    2)从用户的角度看不到被适配者，是解耦的
    3)用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法
    4)用户收到反馈结果，感觉只是和目标接口交互，如图
注意事项和细节:
    1)三种命名方式，是根据src是以怎样的形式给到Adapter(在Adapter里的形式)来命名的。
    2)类适配器:以类给到,在Adapter里,就是将src当做类,继承对象适配器:以对象给到，在Adapter里,
      将src作为一个对象,持有接口适配器:以接口给到,在Adapter里,将src作为一个接口，实现
    3) Adapter模式最大的作用还是将原本不兼容的接口融合在-起工作。
    4)实际开发中,实现起来不拘泥于我们讲解的三种经典形式
SpringMvc中HandlerAdapter,就使用了适配器模式

##桥接模式##
基本介绍
    1)桥接模式(Bridge模式)是指:将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。
    2)是一种结构型设计模式
    3) Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。
        它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，
        从而可以保持各部分的独立性以及应对他们的功能扩展
桥接模式其它应用场景
    1)对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为为适用.
    2)常见的应用场景:
        JDBC驱动程序
        银行转账系统
            转账分类:网上转账，柜台转账，AMT转账
            转账用户类型:普通用户，银卡用户，金卡用户.. .
        消息管理
            消息类型:即时消息，延时消息
            消息分类:手机短信，邮件消息，QQ消息...
桥接模式的注意事项和细节
    1)实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实
    现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。
    2)对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。
    3)桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。
    4)桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，
    要求开发者针对抽象进行设计和编程
    5)桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局.
    限性，即需要有这样的应用场景。

##装饰着模式##(卖咖啡)
装饰者模式定义:
    1)装饰者模式:动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，
        装饰者模式也体现了开闭原则(ocp)
    2)这里提到的动态的将新功能附加到对象和ocp原则，在后面的应用实例上会以代码的形式体现，
        请同学们注意体会。
Java的IO结构，FilterInputStream就是drink
Java的IO结构，Buffer/Data+InputStream就是调料

##组合模式##
基本介绍:
    1)组合模式(Composite Pattern),又叫部分整体模式，它创建了对象组的树形结构，
      将对象组合成树状结构以表示“整体-部分”的层次关系。
    2)组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
    3)这种类型的设计模式属于结构型模式。
    4)组合模式使得用户对单个对象和组合对象的访问具有一致性，即:组合能让客
      户以一致的方式处理个别对象以及组合对象
解决的问题
    1)组合模式解决这样的问题，当我们的要处理的对象可以生成一颗树形结构，而
      我们要对树上的节点和叶子进行操作时，它能够提供一致的方式，而不用考虑它是节点还是叶子
组合模式的注意事项和细节
    1)简化客户端操作。客户端只需要面对- -致的对象而不用考虑整体部分或者节点叶子的问题。
    2)具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.
    3)方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
    4)需要遍历组织机构，或者处理的对象具有树形结构时,非常适合使用组合模式.
    5)要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式
JDK HashMap:用了组合模式

##外观模式##
基本介绍:
    1)外观模式(Facade)，也叫“过程模式:外观模式为子系统中的一组接口提供一个一致的界面，
      此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
    2)外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端
      只需跟这个接口发生调用，而无需关心这个子系统的内部细节
外观模式的注意事项和细节:
    1)外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
    2)外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展
    3)通过合理的使用外观模式，可以帮我们更好的划分访问的层次
    4)当系统需要进行分层设计时，可以考虑使用Facade模式
    5)在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发
      一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性
    6)不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。
    要以让系统有层次，利于维护为目的。
MyBatis 中的Configuration去创建MetaObject对象使用到外观模式

##享元模式##
基本介绍:
    1)享元模式(FlyweightPattern) 也叫 蝇量模式:运用共享技术有效地支持大量细粒度的对象
    2)常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些
      连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
    3)享元模式能够解决 重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是
      创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率
注意事项和细节:
    1)在享元模式这样理解,“享”就表示共享，“元”表示对象
    2)系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，
      我们就可以考虑选用享元模式
    3)用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable存储
    4)享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率
    5)享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有
      固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.
    6)使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。
享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池

##代理模式##(Proxy)
代理模式的基本介绍:
    1)代理模式:为一个对象提供一-个替 身，以控制对这个对象的访问。即通过代理对象访问目标对象.
      这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作即扩展目标对象的功能。
    2)被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象
    3)代理模式有不同的形式，主要有三种静态代理、动态代理(JDK 代理、接口代理)和Cglib代理(可以在内存
      动态的创建对象，而不需要实现接口，他是属于动态代理的范畴)。

##模板方法模式##+钩子方法
    1)在模板方法模式的父类中，我们可以定义一一个方法，它默认不做任何事，子类可以规情况要不要覆盖它，
      该方法称为“钩孙”。
    2)还是用上面做豆浆的例子来讲解，比如，我们还希望制作纯豆浆，不添加任何的配料，
      请使用钩子方法对前面的模板方法进行改造
模板方法模式的注意事项和细节
    1)基本思想是:算法只存在于-一个地方，也就是在父类中，容易修改。需要修改算
      法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改
    2)实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。
    3) 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，
      同时由子类提供部分步骤的实现。
    4)该模式的不足之处:每一个不同的实现都需要一一个 子类实现，导致类的个数增加，使得系统更加庞大
    5)一般模板方法都加.上final关键字，防止子类 重写模板方法.
    6)模板方法模式使用场景:当要完成在某个过程，该过程要执行一系列步骤，这一
      系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理
Spring IOC容器初始化时运用到的模板方法模式

##命令模式##
基本介绍:
    1)命令模式(Command Patterm) :在软件设计中，我们经常需要向某些对象发送请求，
      但是并不知道请求的接收者是谁，也不知道破请水的操作是哪个;
      我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计
    2)命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。
    3)在命名模式中，会将一个请求封装为一个对象，以便使用不同参
      数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。
    4)通俗易懂的理解:将军发布命令，士兵去执行。其中有几个角色:
      将军(命令发布者)、士兵(命令的具体执行者)、命令(连接将军和士兵)。
Invoker是调用者(将军)，Receiver是被调用者(士兵)，
MyCommand是命令，实现了Command接口，持有接收对象
命令模式的注意事项和细节
    1)将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要
      调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对
      象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说:”
      请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。
    2)容易设计一一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令
    3)容易实现对请求的撤销和重做
    4)命令模式不足:可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这
      点在在使用的时候要注意
    5)空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没
      有用空命令，我们每按下一个按键都要判空，这给我们编码带来-定的麻烦。
    6)命令模式经典的应用场景:界面的一个按钮都是一条命令、模拟CMD (DOS命令)
      订单的撤销/恢复、触发-反馈机制
Spring框架的JdbcTemplate就使用到了命令模式



















